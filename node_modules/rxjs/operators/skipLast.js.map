{"version":3,"file":"skipLast.js","sourceRoot":"","sources":["../../src/operators/skipLast.ts"],"names":[],"mappings":";;;;;;AACA,2BAA2B,eAAe,CAAC,CAAA;AAC3C,wCAAwC,iCAAiC,CAAC,CAAA;AAK1E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,kBAA4B,KAAa;IACvC,MAAM,CAAC,UAAC,MAAqB,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC,KAAK,CAAC,CAAC,EAAxC,CAAwC,CAAC;AAC7E,CAAC;AAFe,gBAAQ,WAEvB,CAAA;AAED;IACE,0BAAoB,UAAkB;QAAlB,eAAU,GAAV,UAAU,CAAQ;QACpC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,IAAI,iDAAuB,CAAC;QACpC,CAAC;IACH,CAAC;IAED,+BAAI,GAAJ,UAAK,UAAyB,EAAE,MAAW;QACzC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1B,0DAA0D;YAC1D,2CAA2C;YAC3C,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,uBAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QACtD,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,kBAAkB,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAC/E,CAAC;IACH,CAAC;IACH,uBAAC;AAAD,CAAC,AAhBD,IAgBC;AAED;;;;GAIG;AACH;IAAoC,sCAAa;IAI/C,4BAAY,WAA0B,EAAU,UAAkB;QAChE,kBAAM,WAAW,CAAC,CAAC;QAD2B,eAAU,GAAV,UAAU,CAAQ;QAF1D,WAAM,GAAW,CAAC,CAAC;QAIzB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAI,UAAU,CAAC,CAAC;IACxC,CAAC;IAES,kCAAK,GAAf,UAAgB,KAAQ;QACtB,IAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAE5B,EAAE,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAC5B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAM,YAAY,GAAG,KAAK,GAAG,SAAS,CAAC;YACvC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;YACxB,IAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;YAEpC,IAAI,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC;YAC3B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAClC,CAAC;IACH,CAAC;IACH,yBAAC;AAAD,CAAC,AAxBD,CAAoC,uBAAU,GAwB7C","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}"]}