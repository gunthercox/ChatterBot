{"version":3,"file":"buffer.js","sourceRoot":"","sources":["../../src/operators/buffer.ts"],"names":[],"mappings":";;;;;;AAGA,gCAAgC,oBAAoB,CAAC,CAAA;AAErD,kCAAkC,2BAA2B,CAAC,CAAA;AAG9D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,gBAA0B,eAAgC;IACxD,MAAM,CAAC,gCAAgC,MAAqB;QAC1D,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,cAAc,CAAI,eAAe,CAAC,CAAC,CAAC;IAC7D,CAAC,CAAC;AACJ,CAAC;AAJe,cAAM,SAIrB,CAAA;AAED;IAEE,wBAAoB,eAAgC;QAAhC,oBAAe,GAAf,eAAe,CAAiB;IACpD,CAAC;IAED,6BAAI,GAAJ,UAAK,UAA2B,EAAE,MAAW;QAC3C,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;IAClF,CAAC;IACH,qBAAC;AAAD,CAAC,AARD,IAQC;AAED;;;;GAIG;AACH;IAAkC,oCAAuB;IAGvD,0BAAY,WAA4B,EAAE,eAAgC;QACxE,kBAAM,WAAW,CAAC,CAAC;QAHb,WAAM,GAAQ,EAAE,CAAC;QAIvB,IAAI,CAAC,GAAG,CAAC,qCAAiB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC,CAAC;IACrD,CAAC;IAES,gCAAK,GAAf,UAAgB,KAAQ;QACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAED,qCAAU,GAAV,UAAW,UAAa,EAAE,UAAe,EAC9B,UAAkB,EAAE,UAAkB,EACtC,QAAiC;QAC1C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAChC,CAAC;IACH,uBAAC;AAAD,CAAC,AAnBD,CAAkC,iCAAe,GAmBhD","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> {\n  return function bufferOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferOperator<T>(closingNotifier));\n  };\n}\n\nclass BufferOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingNotifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSubscriber<T> extends OuterSubscriber<T, any> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, closingNotifier));\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    const buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  }\n}\n"]}