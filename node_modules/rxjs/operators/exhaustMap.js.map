{"version":3,"file":"exhaustMap.js","sourceRoot":"","sources":["../../src/operators/exhaustMap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n  ): OperatorFunction<T, R> {\n    return (source: Observable<T>) => source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  }\n\nclass SwitchFirstMapOperator<T, I, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasSubscription: boolean = false;\n  private hasCompleted: boolean = false;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    const index = this.index++;\n    const destination = this.destination;\n    try {\n      const result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private trySelectResult(outerValue: T, innerValue: I,\n                          outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    try {\n      const result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n"]}