{"version":3,"file":"first.js","sourceRoot":"","sources":["../../src/operators/first.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n/* tslint:disable:max-line-length */\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S): OperatorFunction<T, S>;\nexport function first<T, S extends T, R>(predicate: (value: T | S, index: number, source: Observable<T>) => value is S,\n                                         resultSelector: (value: S, index: number) => R, defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                      resultSelector: void,\n                                      defaultValue?: S): OperatorFunction<T, S>;\nexport function first<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\nexport function first<T, R>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: (value: T, index: number) => R,\n                            defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         resultSelector: void,\n                         defaultValue?: T): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: ((value: T, index: number) => R) | void,\n                            defaultValue?: R): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source));\n}\n\nclass FirstOperator<T, R> implements Operator<T, R> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FirstSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n  private hasCompleted: boolean = false;\n  private _emitted: boolean = false;\n\n  constructor(destination: Subscriber<R>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      this._emit(value, index);\n    }\n  }\n\n  private _tryPredicate(value: T, index: number) {\n    let result: any;\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this._emit(value, index);\n    }\n  }\n\n  private _emit(value: any, index: number) {\n    if (this.resultSelector) {\n      this._tryResultSelector(value, index);\n      return;\n    }\n    this._emitFinal(value);\n  }\n\n  private _tryResultSelector(value: T, index: number) {\n    let result: any;\n    try {\n      result = (<any>this).resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this._emitFinal(result);\n  }\n\n  private _emitFinal(value: any) {\n    const destination = this.destination;\n    if (!this._emitted) {\n      this._emitted = true;\n      destination.next(value);\n      destination.complete();\n      this.hasCompleted = true;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n      destination.next(this.defaultValue);\n      destination.complete();\n    } else if (!this.hasCompleted) {\n      destination.error(new EmptyError);\n    }\n  }\n}\n"]}