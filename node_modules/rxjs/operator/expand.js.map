{"version":3,"file":"expand.js","sourceRoot":"","sources":["../../src/operator/expand.ts"],"names":[],"mappings":";AAEA,uBAAsC,qBAAqB,CAAC,CAAA;AAK5D,mCAAmC;AAEnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4CG;AACH,gBAAkD,OAAmD,EACxE,UAA6C,EAC7C,SAAiC;IADjC,0BAA6C,GAA7C,aAAqB,MAAM,CAAC,iBAAiB;IAC7C,yBAAiC,GAAjC,qBAAiC;IAC5D,UAAU,GAAG,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,iBAAiB,GAAG,UAAU,CAAC;IAE3E,MAAM,CAAC,eAAW,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC;AAC3D,CAAC;AANe,cAAM,SAMrB,CAAA","sourcesContent":["import { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { expand as higherOrder } from '../operators/expand';\n\n/* tslint:disable:max-line-length */\nexport function expand<T>(this: Observable<T>, project: (value: T, index: number) => Observable<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function expand<T, R>(this: Observable<T>, project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: IScheduler): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand<T, R>(this: Observable<T>, project: (value: T, index: number) => Observable<R>,\n                             concurrent: number = Number.POSITIVE_INFINITY,\n                             scheduler: IScheduler = undefined): Observable<R> {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\n  return higherOrder(project, concurrent, scheduler)(this);\n}\n"]}