{"version":3,"file":"windowTime.js","sourceRoot":"","sources":["../../src/operator/windowTime.ts"],"names":[],"mappings":";AACA,sBAAsB,oBAAoB,CAAC,CAAA;AAE3C,0BAA0B,mBAAmB,CAAC,CAAA;AAC9C,4BAA4B,qBAAqB,CAAC,CAAA;AAClD,2BAA0C,yBAAyB,CAAC,CAAA;AAwEpE,oBAC8B,cAAsB;IAElD,IAAI,SAAS,GAAe,aAAK,CAAC;IAClC,IAAI,sBAAsB,GAAW,IAAI,CAAC;IAC1C,IAAI,aAAa,GAAW,MAAM,CAAC,iBAAiB,CAAC;IAErD,EAAE,CAAC,CAAC,yBAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9B,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED,EAAE,CAAC,CAAC,yBAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9B,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,qBAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnC,aAAa,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC/B,CAAC;IAED,EAAE,CAAC,CAAC,yBAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9B,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,qBAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnC,sBAAsB,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IAED,MAAM,CAAC,uBAAW,CAAC,cAAc,EAAE,sBAAsB,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC,IAAI,CAA8B,CAAC;AAC1H,CAAC;AAxBe,kBAAU,aAwBzB,CAAA","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { windowTime as higherOrder } from '../operators/windowTime';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Same as example above but with maxWindowCount instead of take</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000, 2) // each window has still at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\n\nexport function windowTime<T>(this: Observable<T>,\n                              windowTimeSpan: number): Observable<Observable<T>> {\n\n  let scheduler: IScheduler = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return higherOrder(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this) as Observable<Observable<T>>;\n}\n"]}