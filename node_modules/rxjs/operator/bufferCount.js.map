{"version":3,"file":"bufferCount.js","sourceRoot":"","sources":["../../src/operator/bufferCount.ts"],"names":[],"mappings":";AAEA,4BAA2C,0BAA0B,CAAC,CAAA;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCG;AACH,qBAAoD,UAAkB,EAAE,gBAA+B;IAA/B,gCAA+B,GAA/B,uBAA+B;IACrG,MAAM,CAAC,yBAAW,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC,IAAI,CAAoB,CAAC;AAC5E,CAAC;AAFe,mBAAW,cAE1B,CAAA","sourcesContent":["\nimport { Observable } from '../Observable';\nimport { bufferCount as higherOrder } from '../operators/bufferCount';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport function bufferCount<T>(this: Observable<T>, bufferSize: number, startBufferEvery: number = null): Observable<T[]> {\n  return higherOrder(bufferSize, startBufferEvery)(this) as Observable<T[]>;\n}\n"]}