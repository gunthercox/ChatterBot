{"version":3,"file":"debounceTime.js","sourceRoot":"","sources":["../../src/operator/debounceTime.ts"],"names":[],"mappings":";AAGA,sBAAsB,oBAAoB,CAAC,CAAA;AAC3C,6BAA4C,2BAA2B,CAAC,CAAA;AAExE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6CG;AACH,sBAAqD,OAAe,EAAE,SAA6B;IAA7B,yBAA6B,GAA7B,yBAA6B;IACjG,MAAM,CAAC,2BAAW,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,IAAI,CAAkB,CAAC;AAChE,CAAC;AAFe,oBAAY,eAE3B,CAAA","sourcesContent":["\nimport { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { debounceTime as higherOrder } from '../operators/debounceTime';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(this: Observable<T>, dueTime: number, scheduler: IScheduler = async): Observable<T> {\n  return higherOrder(dueTime, scheduler)(this) as Observable<T>;\n}\n"]}